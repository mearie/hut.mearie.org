<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>허튼소리</title><link>https://hut.mearie.org/</link><description>허튼소리의 최근 글</description><generator>Hugo -- gohugo.io</generator><language>ko</language><atom:link href="https://hut.mearie.org/index.xml" rel="self" type="application/rss+xml"/><item><title>0의 0제곱</title><link>https://hut.mearie.org/0th-power-of-0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hut.mearie.org/0th-power-of-0/</guid><description>거듭제곱의 특수한 경우로, 대부분의 교과 과정에서는 0으로 나누기와 같이 부정형(indeterminate)으로 본다. 이는 다음 두 가지 사실에서 유래하는데,
x0은 x가 0이 아닐 때는 항상 1이다. 0y는 y가 0보다 클 때는 항상 0이다. 00은 이 두 경우를 확장했을 때 겹치는 값이기 때문에 둘 중 하나를 딱히 결정할 수는 없다. 좀 더 정확히 말하면 물론 $\lim_{t \to 0^+} f(t) = \lim_{t \to 0^+} g(t) = 0$이긴 하지만, $\lim_{t \to 0^+} f(t)^{g(t)}$는 $f(t)$와 $g(t)$에 따라서 다른 극한값이 나올 수 있기 때문에 $\lim_{(x,y) \to (0,0)} x^y$는 부정형이다.</description></item><item><title>Ghoti</title><link>https://hut.mearie.org/english/ghoti/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hut.mearie.org/english/ghoti/</guid><description>Ghoti는 fish의 다른 (그리고 잘못된) 철자이다. 이런 이유로 fish와 같은 /fɪʃ/(국제 음성 기호)로 읽을 수 있다 한다.
gh는 enough, tough 등의 낱말에서 /f/로 발음된다. o는 women에서 /ɪ/로 발음된다. ti는 nation, motion 등의 낱말에서 /ʃ/로 발음된다. 또한 이 낱말은 전혀 발음되지 않을 수도 있다.
gh는 night, fight 등의 낱말에서 발음되지 않는다. o는 people에서 발음되지 않는다. t는 ballet, gourmet, mortgage 등의 낱말에서 발음되지 않는다. i는 business 등의 낱말에서 발음되지 않는다.</description></item><item><title>JSON</title><link>https://hut.mearie.org/json/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hut.mearie.org/json/</guid><description>JSON은 자바스크립트의 (거의) 부분집합으로 시작해서 현재는 언어 불문하고 아주 널리 쓰이는 직렬화 포맷이다. 사실상 모든 프로그래밍 언어에 JSON 라이브러리가 있다고 보아도 좋다. JSON보다 30년 정도 이전에 나온 Apple II에서 돌아가는 JSON 라이브러리도 있을 정도이다.
{ &amp;#34;&amp;#34;: null, &amp;#34;excluded middle&amp;#34;: [true, false], &amp;#34;pi&amp;#34;: { &amp;#34;integer&amp;#34;: 3, &amp;#34;decimal&amp;#34;: 3.141592, &amp;#34;von Neumann ordinal&amp;#34;: [{}, [{}], [{}, [{}]]] }, &amp;#34;https://tvtropes.org/pmwiki/pmwiki.php/Main/DyingClue&amp;#34;: &amp;#34;🍖고기 먹고 싶다\r\n\ud83d\uDC1F앗 물고기잖아?!&amp;#34; } JSON에서 가능한 모든 종류의 값(NULL, 불린형, 정수, 소수, 문자열, 배열, 오브젝트)을 사용하는 예제.</description></item><item><title>They</title><link>https://hut.mearie.org/english/they/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hut.mearie.org/english/they/</guid><description>현대 영어에서 “they”는 인칭 대명사로, 주로 삼인칭 복수에 쓰이지만 단수에도 쓰일 수 있다. 격 변화는 다음과 같다.
격 변화 주격 they 목적격 them 소유격 their 소유대명사 theirs 재귀대명사 themselves, themself 삼인칭 단수에서의 쓰임 # “they”가 삼인칭 단수 양성(epicene) 대명사로 쓰인 역사는 길지만, 공식적으로는 남성 he, 여성 she, 무성 it만이 올바른 대명사로 간주되어 왔다.</description></item><item><title>XML</title><link>https://hut.mearie.org/xml/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hut.mearie.org/xml/</guid><description>XML(eXtensible Markup Language)은 W3C에서 표준화한 마크업 언어와 그에 연관된 기술이다.
&amp;lt;?xml version=&amp;#34;1.0&amp;#34;?&amp;gt; &amp;lt;book xmlns:html=&amp;#34;http://www.w3.org/1999/xhtml&amp;#34;&amp;gt; &amp;lt;title xml:lang=&amp;#34;ko&amp;#34;&amp;gt;그래도 마을은 돌아간다 &amp;lt;part volume=&amp;#34;1&amp;#34;&amp;gt;1권&amp;lt;/part&amp;gt;&amp;lt;/title&amp;gt; &amp;lt;title xml:lang=&amp;#34;ja&amp;#34;&amp;gt;それでも町は廻っている&amp;lt;part volume=&amp;#34;1&amp;#34;&amp;gt;１&amp;lt;/part&amp;gt;&amp;lt;/title&amp;gt; &amp;lt;isbn&amp;gt;978-89-532-7892-9&amp;lt;/isbn&amp;gt; &amp;lt;date&amp;gt;2015-12-17&amp;lt;/date&amp;gt; &amp;lt;publisher&amp;gt; &amp;lt;name&amp;gt;서울문화사&amp;lt;/name&amp;gt;&amp;lt;!-- 현 서울미디어코믹스 --&amp;gt; &amp;lt;url&amp;gt;https://www.ismg.co.kr/&amp;lt;/url&amp;gt; &amp;lt;/publisher&amp;gt; &amp;lt;author class=&amp;#34;글 그림&amp;#34;&amp;gt; &amp;lt;name&amp;gt;이시구로 마사카즈&amp;lt;/name&amp;gt; &amp;lt;/author&amp;gt; &amp;lt;notes&amp;gt; &amp;lt;html:div&amp;gt;메이드 카페는 나오지 않습니다.&amp;lt;/html:div&amp;gt; &amp;lt;/notes&amp;gt; &amp;lt;/book&amp;gt; 책 정보를 나타내는 XML의 예제. 반구조화된 데이터(제목), 주석, 언어 태깅(xml:lang), XML 네임스페이스를 사용한 확장 등이 보인다.
본디 ISO가 표준화한 SGML(ISO 8879:1986)을 기반으로 해서 겉보기 문법은 거의 같지만, SGML이 허용하는 상당한 유연성을 포기하는 대신 인터넷에서 쓰기 좋도록 크게 단순화한 것이다.</description></item><item><title>XY 문제</title><link>https://hut.mearie.org/xy-problem/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hut.mearie.org/xy-problem/</guid><description>XY 문제(XY problem)는 기술 지원이나 고객 서비스에서 흔히 보이는 두 종류의 문제를 가리키며, 공통적으로 X라는 문제를 해결하기 위해서 Y라는 방법이 필요하다 주장하는데 그게 틀렸다는 걸 인지하지 못하는 것을 가리킨다.
제 1종 # 제 1종 XY 문제는 소비자·질문자가 해결책 Y를 지레짐작하여 진짜 문제 X를 언급하지 않는 상황에 일어난다. 이전에도 널리 알려진 문제긴 했지만, 에릭 레이먼드(Eric Raymond)의 〈똑똑하게 질문하기(How To Ask Questions The Smart Way)〉에 나오는 다음 예시의 영향으로 ‘XY 문제’라는 이름이 붙은 것으로 보인다.</description></item><item><title>계산</title><link>https://hut.mearie.org/computing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hut.mearie.org/computing/</guid><description>계산(computation, computing)은 좁은 의미로는 수식의 단순화를 이른다. 요컨대 다음 세 과정은 각각 계산이다.
$$7 \times 8 \mapsto 56 \qquad (\sqrt{2})^3 \mapsto 2.828427\cdots \qquad (\sqrt{2})^3 \mapsto 2\sqrt{2}$$
넓은 의미에서 계산은 잘 정의된 입력을 그에 의존하는 다른 잘 정의된 출력으로 변환하는 모든 과정을 이른다. 여기에는 좁은 의미에서의 계산 뿐만 아니라, 모든 종류의 알고리즘 및 인간의 사고와 우주 그 자체까지 포함될 수 있다.
계산을 빠르게 기계적으로 할 수 있는 장치를 컴퓨터(computer)라고 부른다. 이 낱말은 19세기부터 20세기 초반 사이에 기계식 컴퓨터가 널리 퍼지기 전에는 계산을 하는 사람, 즉 계산수를 가리키는 말이었는데, 인류가 계산 그 자체에 대해서 사유하기 시작한 것이 이 시점과 얼추 비슷하기 때문에 ‘계산 = 컴퓨터가 하는 일’이라는 오개념이 널리 퍼져 있다.</description></item><item><title>도대체 이게 뭡니까?</title><link>https://hut.mearie.org/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hut.mearie.org/about/</guid><description>지난 십수년간 수차례 글을 쓸 공간을 만들고 때려 치고 하기를 반복했습니다. 대략 네다섯개 정도 되는 블로그부터 시작해서, 위키도 두어 번 만들고, 개인 웹사이트라는 것이 사라져가는 시대에 들어서는 트위터나, 해커뉴스나, (아직도 진득하게 운영하는) IRC나 디스코드 서버나 그런 곳에서 오만가지 잡소리를 싸 댔습니다.
처음에는 글 쓰기가 지겨워져서라고 생각했습니다.
시간이 지나서는 글을 효율적으로 쓸 수 없는 컨텐츠 관리 시스템이 없기 때문이라고 생각했습니다.
시간이 더 지나서야 글을 쓰는 게 문제가 아니라, 작게 쓴 글을 모으는 게 문제라는 걸 깨달았습니다.</description></item><item><title>리듬 게임</title><link>https://hut.mearie.org/rhythm-game/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hut.mearie.org/rhythm-game/</guid><description>리듬 게임은 액션 게임의 일종으로, 음악, 그 중에서도 특히 그 박자(리듬)를 주 게임 요소로 사용하는 것을 총칭한다. 이론적으로 박자가 아닌 다른 요소를 사용하는 게임은 상위 분류로서 “음악 게임”에 속하는 것이 옳으나, 음악은 사용하는데 박자는 사용하지 않는 것이 사실상 불가능하여 거의 모든 음악 게임은 리듬 게임의 요소를 가지고 있다 할 수 있다.
코어 리듬 게임 # 매우 많은 리듬 게임이 다음과 같은 요소를 가지고 있다.
박자 요소에 직접적으로 대응되는 예측 가능한 게임 오브젝트 해당 박자에 오브젝트와 겹치게 조정된 판정 영역 오브젝트가 판정 영역을 향해 이동하는 궤적 (미리 보여 주기도 하고, 숨기기도 한다) 박자에 맞게 조작해야 하는 플레이어 컨트롤 박자의 정확도를 시각적으로 보여주는 판정 연속해서 좋은 판정을 낸 횟수를 나타내는 콤보 숫자 워낙 익숙해서 이들 요소가 당연한 것이라고 생각할 수 있지만 그렇지 않다.</description></item><item><title>브레인퍽을 배워 보자</title><link>https://hut.mearie.org/brainfuck/lets-learn/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hut.mearie.org/brainfuck/lets-learn/</guid><description>초기화 및 문자열 출력 # 가장 간단한 예제는 항상 정해진 내용만 출력하는 코드일 것이다. 이는 현재 칸의 값을 +와 -로 이리 저리 바꿔 가면서 간단하게 만들 수 있다. 예를 들어 -_-(ASCII 값 45, 95, 45)을 출력한다면,
+++++++++++++++++++++++++++++++++++++++++++++.현재 칸을 45로 만들고 출력 ++++++++++++++++++++++++++++++++++++++++++++++++++.현재 칸에 50을 더해 95로 만들고 출력 --------------------------------------------------.현재 칸에 50을 빼 45로 만들고 출력 이런 느낌이 된다. 그러나 45를 한 번 만들었다면 세번째 문자는 이미 만든 45를 다시 쓰면 되는 게 아닌가 하는 생각이 들 수 있는데, 이 때문에 어떤 칸에 있는 숫자를 다른 칸에 “더하는” 코드가 많이 등장한다.</description></item><item><title>비트</title><link>https://hut.mearie.org/bit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hut.mearie.org/bit/</guid><description>비트(bit)는 정보의 단위이다. “이진법 자리”(binary digit)의 준말이니만큼, 1비트는 두 가지 서로 다른 값을 가질 수 있는 정보의 정보량을 가리킨다. 정보량은 곱해지므로 k비트의 정보는 2k가지 서로 다른 값을 가질 수 있다.
비트는 정보 엔트로피의 단위이기도 한데, 두 가지 서로 다른 값을 가질 수 있는 확률 변수에서 각 선택지의 확률이 동일할 때의 엔트로피가 1비트이다. 다르게 말하면 해당 확률 변수의 값이 알려졌을 때 얻어지는 정보의 양(information gain)이 1비트인 것이다.
관련 단위 비트는 굉장히 작은 단위이므로 한 번에 다룰 수 있는 비트들의 묶음인 바이트나 바이트에서 유래한 더 큰 단위를 쓰는 게 보통이다.</description></item><item><title>소셜 네트워크 사이트</title><link>https://hut.mearie.org/social-network-site/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hut.mearie.org/social-network-site/</guid><description>소셜 네트워크 사이트(SNS)는 기존 인간 관계를 인터넷 상으로 옮기거나 새로운 종류의 인간 관계를 만드는 것이 목적인 사이트이다. 하지만 인간 관계와 관련해서는 언제나 그렇듯, 이런 시도는 대부분 파국적이다.
옛날 글 The same argument works with Twitter, and I genuinely believed so a decade ago (Twitter has been the only social network I still continuously use). I don&amp;rsquo;t buy it at all after the decade-long experience. Your favorite followers will fight to each other no matter you&amp;rsquo;ve carefully chosen them.</description></item><item><title>아직 쓰지 않은 글</title><link>https://hut.mearie.org/not-found/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hut.mearie.org/not-found/</guid><description> 이 글은 아직 쓰지 않았습니다. var parts = decodeURIComponent(location.hash.slice(1)).split(/:/g); if (parts.length = 2 &amp;&amp; parts[0].match(/^\/(?:[a-z0-9-.]+\/)+$/)) { var anchor = document.createElement('a'); anchor.textContent = '원래 페이지로 돌아갑니다.'; anchor.href = parts[0]; document.write(anchor.outerHTML + ' 또는 '); } 하단의 링크로 작성 요청을 보내실 수 있습니다.</description></item><item><title>아희</title><link>https://hut.mearie.org/aheui/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hut.mearie.org/aheui/</guid><description>아희는 2005년에 정경훈(Puzzlet Chung)이 만든 한글 난해한 프로그래밍 언어이다.
밤밣따빠밣밟따뿌　→→→→→→→┐ 빠맣파빨받밤뚜뭏　┌→→→→→┐↓ 돋밬탕빠맣붏두붇　↑┌→→→┐↓↓ 볻뫃박발뚷투뭏붖　↑↑┌→┐↓↓↓ 뫃도뫃희멓뭏뭏붘　↑↑↑희┘↓↓↓ 뫃봌토범더벌뿌뚜　↑↑└←←┘↓↓ 뽑뽀멓멓더벓뻐뚠　↑└←←←←┘↓ 뽀덩벐멓뻐덕더벅　└←←←←←←┘ “Hello, world!” 프로그램과 그 실행 궤적. 잘 알려져 있진 않지만 이 코드는 내가 짰다.
아희는 한국어권에서 만들어진 것 중에서는 가장 잘 알려진 난해한 프로그래밍 언어이다.
아직 작성 중입니다.</description></item><item><title>앞서 보기 스트림</title><link>https://hut.mearie.org/lookahead-stream/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hut.mearie.org/lookahead-stream/</guid><description>앞서 보기(lookahead) 스트림은 스트림 중에서도 다음에 읽을 원소를 최대 k개까지 볼 수 있는 기능을 제공하는 자료형이다. 파싱에 특히 유용하게 쓰이는데, 대부분의 파서에서는 다음 입력(들)을 보고 다음에 할 동작을 결정해야 하기 때문이다. 이를테면 문자로 이루어진 스트림이 앞서 보기를 지원할 경우 123 등의 정수를 이렇게 읽을 수 있다.
‘읽은 정수’를 0으로 초기화한다. 다음에 읽을 문자가 0부터 9 사이면(앞서 보기), 해당 문자를 읽어서 0부터 9 사이의 ‘자릿수’를 결정한다. ‘읽은 정수’에 10을 곱한 뒤 그 ‘자릿수’를 더한다.</description></item><item><title>연산자 우선순위</title><link>https://hut.mearie.org/operator-precedence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hut.mearie.org/operator-precedence/</guid><description>연산자 우선순위(operator precedence)는 주어진 식에서 어느 연산이 먼저 계산되는 지를 나타낸다. 예를 들어서 일반적인 사칙 연산을 기준으로 다음이 성립한다. $$3 + 4 \times 5 \times 6 = 3 + ((4 \times 5) \times 6) = 3 + (20 \times 6) = 3 + 120 = 123$$ 이 식이 성립하는 이유는 우리가 덧셈($+$)에 앞서 곱셈($\times$)을 먼저 계산하고, 덧셈과 곱셈 모두 연달아 나올 경우 왼쪽부터 계산한다고 약속했기 때문이다. 이는 곱의 합이 합의 곱보다 더 많이 나타나므로 이리 하면 괄호를 줄일 수 있다는 경험칙에 따른 것이며 그 이상 그 이하도 아니다.</description></item><item><title>윤초</title><link>https://hut.mearie.org/leap-second/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hut.mearie.org/leap-second/</guid><description>협정 세계시(UTC)에서 윤초(leap second)는 평균 태양시와의 오차를 보정하기 위해 가끔 추가되거나 삭제되는 초를 가리킨다.
하루의 길이(LOD, length of day)는 정확히 86 400초가 아니고, 지구 자전 속도의 변화에 따라 바뀔 수 있어서 일정하지 않다. 이 때문에 누적된 오차를 청산하기 위해, 지정된 달의 마지막 날 23:59:59(UTC 기준)를 삭제하여 하루를 86 399초로 만들거나(음의 윤초), 23:59:60을 추가하여 하루를 84 001초로 만드는 것이다(양의 윤초). UTC가 시작된 1972년 이래 윤초는 2021년 6월까지 27회 추가되었으며 삭제된 적은 없다.</description></item><item><title>재귀</title><link>https://hut.mearie.org/recursion/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hut.mearie.org/recursion/</guid><description>재귀(recursion)는 통상적으로는 자가 참조(self-reference)를 가리킨다. 예를 들어서 이 문단에는 한글만 세어서 일흔 두개의 글자와 스물 네개의 낱말이 있다. (이러한 식의 자가 참조를 오토그램이라고 부른다.)
그러나 재귀와 자가 참조는 다르다. 수학과 프로그래밍에서 재귀는 귀납적인(inductive) 구조를 이른다. 이를테면 페아노 공리에 따라 0을 포함하는 자연수는 다음과 같이 재귀적·귀납적으로 정의할 수 있다.
바탕 단계: 0은 자연수이다.
귀납 단계: n이 자연수이면 S(n)은 자연수이다.
그러니까 우리가 1, 2, …라고 부르는 것은 S(0), S(S(0)), …을 줄여 부르는 것이다.</description></item><item><title>프로그램</title><link>https://hut.mearie.org/program/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hut.mearie.org/program/</guid><description>컴퓨터에서 프로그램(program)은 컴퓨터가 할 일을 명령의 형태로 나열한 것이다.
프로그램을 작성하는 행위를 프로그래밍(programming), 프로그램을 작성하는 사람을 프로그래머(programmer)라고 한다. 프로그램은 일반적으로 프로그래밍 언어로 작성된 소스 코드(source code)로부터 유도되며, 프로그램에 필요한 데이터를 포함한 제품으로서의 소프트웨어(software)의 일부가 된다. 방송 편성과 같이 컴퓨터가 아닌 곳에서도 프로그램·프로그래밍·프로그래머라는 말을 쓰는 경우가 있으니 주의가 필요하다.
관련 개념 # 프로그램과 연관된 개념들. 앞에서 뒤로 갈수록 더 큰 단위이다.
행위물 행위 행위자 행위물의 사전적 의미 소스 코드 (source code) 코딩 (coding) 코더 (coder) 인간이 읽고 쓰는 프로그램의 원본.</description></item></channel></rss>