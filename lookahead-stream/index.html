<!doctype html><html lang=ko><head><meta charset=utf-8><title>앞서 보기 스트림 | 허튼소리</title><meta name=viewport content="width=device-width,minimum-scale=1,maximum-scale=1"><meta name=description content="앞서 보기(lookahead) 스트림은 스트림 중에서도 다음에 읽을 원소를 최대 k개까지 볼 수 있는 기능을 제공하는 자료형이다. 파싱에 특히 유용하게 쓰이는데, 대부분의 파서에서는 다음 입력(들)을 보고 다음에 할 동작을 결정해야 하기 때문이다. 이를테면 문자로 이루어진 스트림이 앞서 보기를 지원할 경우 123 등의 정수를 이렇게 읽을 수 있다.
 ‘읽은 정수’를 0으로 초기화한다. 다음에 읽을 문자가 0부터 9 사이면(앞서 보기),  해당 문자를 읽어서 0부터 9 사이의 ‘자릿수’를 결정한다. ‘읽은 정수’에 10을 곱한 뒤 그 ‘자릿수’를 더한다."><meta name=generator content="Hugo 0.80.0"><link rel="shortcut icon" href=/favicon.ico type=image/vnd.microsoft.icon><style>@charset "UTF-8";@import "https://fonts.googleapis.com/css2?family=Noto+Serif&family=Noto+Serif+KR:wght@200;700&display=swap";*,*::before,*::after{box-sizing:border-box}body,h1,h2,h3,h4,p,figure,blockquote,dl,dd{margin:0}ul[role=list],ol[role=list]{list-style:none}html:focus-within{scroll-behavior:smooth}body{min-height:100vh;text-rendering:optimizeSpeed;line-height:1.5}a:not([class]){text-decoration-skip-ink:auto}img,picture{max-width:100%;display:block}input,button,textarea,select{font:inherit}@media(prefers-reduced-motion:reduce){html:focus-within{scroll-behavior:auto}*,*::before,*::after{animation-duration:.01ms!important;animation-iteration-count:1!important;transition-duration:.01ms!important;scroll-behavior:auto!important}}html{font-family:noto serif kr,serif;font-weight:200;font-size:18px;--main-color: #758;--light-color: #97a}:lang(en),[lang$=-fonipa]{font-family:noto serif,serif}:lang(en) pre:lang(en),:lang(en) [lang$=-fonipa],:lang(en) code:lang(en),:lang(en) [lang$=-fonipa],[lang$=-fonipa] pre:lang(en),[lang$=-fonipa] [lang$=-fonipa],[lang$=-fonipa] code:lang(en),[lang$=-fonipa] [lang$=-fonipa]{font-family:monospace}body{width:50rem;margin:0 auto;padding:1rem 0 0;line-height:1.8}@media screen and (max-width:936px){body{width:auto;margin:0 1rem;overflow-x:hidden}}*{vertical-align:bottom}.katex,.katex *{vertical-align:baseline}sup{vertical-align:super;line-height:0}sub{vertical-align:sub;line-height:0}p{margin:1rem 0}h1{font-size:2rem;margin:1rem 0}h2{font-size:1.6rem;margin:2rem 0 1rem}h3{font-size:1.2rem;margin:1rem 0}h6{font-size:1rem;margin:0 1rem 0 0;float:left}h1>.link-to-here,h2>.link-to-here,h3>.link-to-here{display:none}h1:hover>.link-to-here,h1:focus>.link-to-here,h2:hover>.link-to-here,h2:focus>.link-to-here,h3:hover>.link-to-here,h3:focus>.link-to-here{display:inline;color:gray}ul,ol{padding:0 0 0 1rem}li{margin:1rem 0}::marker{font-size:.9rem;color:var(--main-color);font-weight:700}blockquote{border-left:.3rem solid #758;padding-left:.3rem;margin-left:-.6rem}table{font-size:.8rem;border-collapse:collapse;min-width:20rem;max-width:100%;display:block;overflow-x:auto;white-space:nowrap}.table-wrap table{display:table;white-space:normal}td,th{padding:.3rem .5rem;text-align:left;margin:0;vertical-align:top}th{white-space:nowrap}tr:first-child{border-top:2px solid #758}tr:last-child{border-bottom:2px solid #758}thead{position:sticky;top:0;background-color:#758;color:#fff;--main-color: #d4c5db;--light-color: white}tbody tr:nth-child(2n){background-color:#efeaf2}aside{background-color:#ebe5ef;margin:1rem .2rem 1.2rem 0;padding:1rem;border-radius:.2rem;border:1px solid #d4c5db;box-shadow:.2rem .2rem .2rem #758}aside>:first-child{margin-top:0}aside>:last-child{margin-bottom:0}strong,b{font-weight:700}em,i{font-style:italic}u{text-decoration:underline}s,del{text-decoration:line-through;color:var(--main-color)}code{color:var(--main-color)}pre{background-color:#ebe5ef!important;tab-size:4;padding:.5em;overflow-x:auto;font-family:monospace}.compact-pre pre{line-height:1}small{font-size:.8em;color:var(--main-color)}small.claim{font-size:1em;background-color:#758;color:#fff;--main-color: #d4c5db;--light-color: white;padding:0 0 0 .2em;margin:0 .4em 0 0;font-weight:700;position:relative}small.claim>span{display:none}small.claim:after,small.claim:before{content:"";position:absolute;left:100%;width:.4em;height:50%}small.claim:before{top:0;background:linear-gradient(to top right,#758 50%,transparent 51%)}small.claim:after{bottom:0;background:linear-gradient(to bottom right,#758 50%,transparent 51%)}a{color:inherit;text-decoration:none;box-shadow:inset 0 -.4ex 0 #d4c5db;transition:background-color .1s cubic-bezier(0.33,0.66,0.66,1)}a:hover{background-color:#d4c5db}a.keyword{box-shadow:inset 0 -.4ex 0 #b6d1c8}a.keyword:hover{background-color:#b6d1c8}a.dead{box-shadow:inset 0 -.4ex 0 #e0ab96;transition:box-shadow .1s cubic-bezier(0.33,0.66,0.66,1);cursor:not-allowed}a.dead:hover{background-color:transparent;box-shadow:inset 0 -.2ex 0 #e0ab96}header{color:#758}header hgroup>h2{font-size:1rem;margin-bottom:0}header hgroup>h1{margin-top:0}details.hn,details.tw{font-size:.9rem}details.changes{width:30rem;margin:-.5rem 0 -.5rem auto;font-size:.8rem}details.changes>summary{text-align:right;cursor:pointer}details.changes>summary::after{content:' (클릭하여 자세히 보기)'}details.changes[open]{border-top:1px solid #758;border-bottom:1px solid #758}details.changes[open]>summary{display:none}@media screen and (max-width:576px){details.changes{width:auto}}figcaption{font-size:.8rem;font-weight:700;margin:.5rem}figcaption>:first-child{margin-top:0}figcaption>:last-child{margin-bottom:0}pre+figcaption,div.highlight+figcaption{margin:-1rem 0 0;background-color:#758;color:#fff;--main-color: #d4c5db;--light-color: white;padding:.5rem}main{margin-top:-100px}main:before{display:block;content:'';margin-top:100px}nav>h2{font-size:1.2rem;margin:0 .5rem 0 0;clear:left;float:left}nav>ul.keywords{padding:0}nav>ul.keywords ul{display:inline;padding:0}nav>ul.keywords li{display:inline}nav>ul.keywords li a{margin:0 .5rem 0 0}nav>ul.keywords>li{font-size:1.2rem}nav>ul.keywords>li li{opacity:.6;font-size:1rem}footer{border-top:1px solid #758;padding-top:.3rem;margin:5rem 0 2rem;font-size:.8rem;color:#758}footer svg.logo{float:right;margin:-.3rem 0 0 2rem;height:2.7rem;fill:#758;vertical-align:middle}</style></head><body><main role=main><article><header><hgroup><h2><a class=keyword href=/data-type/>자료형</a> »</h2><h1>앞서 보기 스트림</h1></hgroup><details class=changes><summary><strong><time>2021-03-28</time></strong> 작성</summary><p><strong><time>2021-03-28</time></strong>에 한국 러스트 사용자 그룹에서의 대화로부터 영감을 받아 첫 작성.</p></details></header><p>앞서 보기(lookahead) 스트림은 <a class=dead href=/not-found/#%2flookahead-stream%2f:stream>스트림</a> 중에서도 다음에 읽을 원소를 최대 k개까지 볼 수 있는 기능을 제공하는 <a class=keyword href=/data-type/>자료형</a>이다.
<a class=dead href=/not-found/#%2flookahead-stream%2f:parsing>파싱</a>에 특히 유용하게 쓰이는데,
대부분의 파서에서는 다음 입력(들)을 보고 다음에 할 동작을 결정해야 하기 때문이다.
이를테면 문자로 이루어진 스트림이 앞서 보기를 지원할 경우 <code>123</code> 등의 정수를 이렇게 읽을 수 있다.</p><ol><li>‘읽은 정수’를 0으로 초기화한다.</li><li><strong>다음에 읽을 문자가 <code>0</code>부터 <code>9</code> 사이면</strong>(앞서 보기),<ul><li>해당 문자를 읽어서 0부터 9 사이의 ‘자릿수’를 결정한다.</li><li>‘읽은 정수’에 10을 곱한 뒤 그 ‘자릿수’를 더한다.</li><li>2번으로 다시 돌아간다.</li></ul></li><li>이제 더 이상 읽을 숫자가 없으므로 ‘읽은 정수’를 반환한다.</li></ol><p>이 때 <code>123,45</code> 같은 입력이 들어 올 경우 3번에 도달했을 때 다음으로 읽게 되는 문자는 <code>4</code>가 아니라 그 앞의 <code>,</code>가 된다.
이러한 동작은 다음에 있는 원소를 읽는 기능만 있을 경우 불가능하다.</p><p>앞서 보기를 할 수 없는 경우 파싱할 수 있는 언어가 크게 줄어든다는 것이 이론적으로 알려져 있으며,
특정 종류의 파서에서 최소 k개의 원소를 앞서 볼 수 있어야 파싱할 수 있는 언어를 <a class=dead href=/not-found/#%2flookahead-stream%2f:ll-parser>LL(k)</a>, <a class=dead href=/not-found/#%2flookahead-stream%2f:lr-parser>LR(k)</a>, <a class=dead href=/not-found/#%2flookahead-stream%2f:lalr-parser>LALR(k)</a> 등으로 따로 부른다.
현실에서 보게 되는 거의 모든 문법들은 k ≤ 1이므로 앞서 보기 스트림도 k = 1로 구현된 경우가 가장 흔하다.</p><p>이러한 유용성에도 불구하고 앞서 보기 스트림의 인터페이스는 표준화가 잘 되어 있지 않은데다,
직접 만들어 써야 하는 경우도 드물지 않다.
일반적으로는 특정 인터페이스를 쓴다고 구현이 불가능해지는 경우는 없지만,
이 인터페이스가 구현 편의에 직접 영향을 미치기 때문에 허투루 고를 수도 없다.</p><h2 id=peek><code>peek</code> <a class=link-to-here href=#peek title="이 제목으로 링크하기">#</a></h2><p>이 인터페이스에서는 다음 연산을 지원한다.</p><ul><li><p><code>next := read()</code>는 입력을 하나 읽어들여 반환한다.</p></li><li><p><code>next := peek(n)</code>은 다음 n번째 <code>read()</code>가 반환할 값을 반환한다(1 ≤ n ≤ k).
n = 1일 때가 흔하므로 이 경우에는 보통 n을 생략한다.
물론 몇 번이든 호출해도 <code>read()</code>의 반환값은 바뀌지 않는다.</p></li></ul><p>이 접근은 <code>read()</code>의 동작을 바꾸지 않기 때문에 기존의 스트림 인터페이스를 크게 바꾸지 않고,
실수할 여지도 별로 없으므로 일반적인 자료 구조에서 선호된다.
하지만 파서에서는 <code>peek()</code>했던 값을 곧바로 <code>read()</code>하는 경우가 아주 흔하기 때문에 대단히 귀찮다.</p><h6>주요 사례</h6><p><a class=dead href=/not-found/#%2flookahead-stream%2f:rust>Rust</a> <a href=https://doc.rust-lang.org/std/iter/struct.Peekable.html><code>std::iter::Peekable</code></a> 등.</p><h2 id=unread-without-argument>인자 없는 <code>unread</code> <a class=link-to-here href=#unread-without-argument title="이 제목으로 링크하기">#</a></h2><p>이 인터페이스에서는 다음 연산을 지원한다.</p><ul><li><p><code>next := read()</code>는 입력을 하나 읽어들여 반환한다.</p></li><li><p><code>unread()</code>는 입력 위치를 앞으로 하나 당긴다.
단 가장 많이 읽은 입력으로부터 앞으로 k개까지만 당길 수 있다.</p></li></ul><p><code>unread()</code>의 k개 제한은 다소 이해하기 어려울 수 있는데,
보통 스트림에 있는 전체 입력을 다 가지고 있는 게 아니라 필요할 때마다 읽어 들이기 때문에,
고정 크기의 <a class=dead href=/not-found/#%2flookahead-stream%2f:array>배열</a>에 최근 입력을 보존하려다 보니 생기는 제한이다.
전체 입력을 바로 꺼내 볼 수 있는 경우 이런 제한은 필요하지 않다.</p><p>이 접근은 호출 숫자를 크게 줄일 수 있어서 특히 파서를 손으로 직접 짤 때 흔히 쓰인다.
하지만 <code>read()</code>를 하지 않았는데 <code>unread()</code>를 실수로 호출해서 입력 위치를 망가뜨리는 상황을 막을 수 없다는 단점이 있다.</p><h2 id=unread-with-argument>인자 있는 <code>unread</code> <a class=link-to-here href=#unread-with-argument title="이 제목으로 링크하기">#</a></h2><p>이 인터페이스에서는 내부적으로 최대 k개까지의 입력을 보존할 수 있는 <a class=dead href=/not-found/#%2flookahead-stream%2f:stack>스택</a>이 있어서,
다음 연산을 지원한다.</p><ul><li><p><code>next := read()</code>는 <strong>스택에 값이 있으면 맨 위의 값을 꺼내서 반환하고,</strong>
아니면 새 입력을 하나 읽어 들여 반환한다.</p></li><li><p><code>unread(prev)</code>는 받은 값을 스택 위에 넣는다.</p></li></ul><p>이 접근은 인자 없는 <code>unread</code>와 겉보기에 별 차이는 없지만 구현이 훨씬 간단하다.
특히 k > 1일 때 인자가 없으면 어디까지 <code>unread</code>를 했고 어디까지 <code>read</code>를 했는지를 따로 관리해야 하지만,
이 접근에서는 그냥 <code>unread</code> 이후 <code>read</code>에서 꺼내지 않은 입력의 숫자만 세면 된다.</p><p>이 접근의 단점이자 장점은 <strong><code>read()</code>에서 반환한 값과 <code>unread()</code>에 전달되는 값이 다를 수 있다</strong>는 것이다.
따라서 조금만 실수해도 바로 이해하기 어려운 버그가 발생할 수 있다.
그럼에도 불구하고 이게 장점일 수 있는 이유는,
다른 연산들과는 달리 이 연산은 다른 인터페이스로 흉내낼 수 없는 새로운 기능이기 때문이다.
그래서 구현이 간단하다는 점과 맞물려 손으로 짤 때는 문제를 감수하고 이 접근을 쓰는 경우가 대단히 많다.</p><aside class=note><p>실제 사례로서, <code>&lt;</code>와 <code>></code>를 (주로 <a class=dead href=/not-found/#%2flookahead-stream%2f:generic-type>일반화 타입</a>의) 구분자로 쓰는 언어에서는 <code>>></code>와 혼동되는 것을 어떻게든 해결할 필요가 있다.
파서가 토큰화 단계와 소통을 한다거나 하는 다양한 방법으로 해결할 수 있는데,
<a href=https://github.com/devcat-studio/kailua/>카일루아</a>의 경우 <code>>></code>를 두 개의 <code>></code>로 처리해야 하는 상황이 되면 <a href=https://github.com/devcat-studio/kailua/blob/323caab/kailua_syntax/src/parser.rs#L2469-L2478>하나의 <code>></code>만 처리한 뒤에 다른 <code>></code>를 스트림에 되돌려 넣는 방법</a>을 썼다.
보통 이러한 상황은 버그이기 때문에 다른 데서는 <code>unread()</code>를 직접 쓰지 않고 <a href=https://github.com/devcat-studio/kailua/blob/323caab/kailua_syntax/src/parser.rs#L319-L350>매크로로 감싸</a> 사용하였다.</p></aside><h6>주요 사례</h6><p><a class=keyword href=/c-language/>C</a> <a href=https://en.cppreference.com/w/c/io/ungetc><code>ungetc</code></a> 등.</p><h2 id=checkpoint>체크포인트 <a class=link-to-here href=#checkpoint title="이 제목으로 링크하기">#</a></h2><p>이 인터페이스에서는 다음과 같은 연산을 제공한다.</p><ul><li><p><code>checkpoint := save()</code>는 현재 스트림의 상태를 반환한다.</p></li><li><p><code>restore(checkpoint)</code>는 현재 스트림의 상태를 복원한다.</p></li></ul><p>이 접근은 어느 시점에 생성한 <code>checkpoint</code>라도 올바르게 복원할 수 있다는 점에서 <code>unread()</code> 계열 접근과 구분된다.
따라서 읽을 수 있는 원소의 갯수 k에 제한이 없고,
토큰은 한 시점에서 여러 개 읽어서 쓸 수 있지만 체크포인트는 그런 경우가 드물기 때문에 실수로 엉뚱한 시점으로 복원할 가능성도 적다.</p><p>이 접근의 단점은 이런 방법을 쓸 수 있는 상황 자체가 한정된다는 것이다.
우선 전체 스트림을 어느 시점에라도 접근할 수 있어야 하며,
<code>save()</code>가 자주 호출되기 때문에 상태도 아주 가벼워야 한다.</p><h6>주요 사례</h6><p>엄밀히는 스트림은 아니지만,
<a class=dead href=/not-found/#%2flookahead-stream%2f:javascript>자바스크립트</a> <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastIndex><code>RegExp.lastIndex</code></a>가 이 인터페이스와 아주 유사하다.
이 때문에 가볍게 짠 자바스크립트 파서에서 특히 이런 접근이 자주 보인다.</p></article></main><footer><svg class="logo" version="1.0" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 182 186"><path d="M0 0h54v102H19v52h35v32H0m34-70h20v24H34"/><path d="M64 0h54v1e2a22 22 0 000 56v30H64m54-72a12 12 0 000 28v-28"/><path d="M128 0h54v102h-33v12h33v8h-33v32h33v32h-54m35-52h19v8h-19"/></svg><strong><a href=/>허튼소리</a></strong>는 <a href=https://mearie.org/>메아리</a>의 일부입니다.
&copy; 2021 강 성훈.
<a href=/about/#license>저작권을 조금 가집니다.</a><br>이 페이지에 대한 의견은 <a href="mailto:?to=hut%2blookahead-stream@.org&subject=%5blookahead-stream%5d%20%ec%9d%98%ea%b2%ac&body=%ec%a0%80%eb%8a%94%20%27%ec%95%9e%ec%84%9c%20%eb%b3%b4%ea%b8%b0%20%ec%8a%a4%ed%8a%b8%eb%a6%bc%27%20%ea%b8%80%ec%9d%84%20%ec%b2%98%ec%9d%8c%eb%b6%80%ed%84%b0%20%eb%81%9d%ea%b9%8c%ec%a7%80%20%ec%9e%98%20%ec%9d%bd%ec%97%88%ea%b3%a0%20%eb%a1%9c%eb%b4%87%ec%9d%b4%20%ec%95%84%eb%8b%88%eb%a9%b0%20%ec%98%ac%eb%b0%94%eb%a5%b8%20%eb%a9%94%ec%95%84%eb%a6%ac%20%eb%8f%84%eb%a9%94%ec%9d%b8%28%ed%97%88%ed%8a%bc%ec%86%8c%eb%a6%ac%20%eb%8f%84%eb%a9%94%ec%9d%b8%20%eb%a7%90%ea%b3%a0%29%ec%9d%84%20%ec%b1%84%ec%9a%b0%ea%b3%a0%20%ec%9d%b4%20%ec%a4%84%ec%9d%84%20%ec%a7%80%ec%9a%b8%eb%a7%8c%ed%95%9c%20%ec%b5%9c%ec%86%8c%ed%95%9c%ec%9d%98%20%ec%a7%80%eb%8a%a5%ec%9d%b4%20%ec%9e%88%ec%9d%8c%ec%9d%84%20%ed%99%95%ec%9d%b8%ed%95%a9%eb%8b%88%eb%8b%a4."><code>hut+lookahead-stream@</code></a>에 보내 주세요.</footer><script type=text/javascript>var _paq=window._paq=window._paq||[];(function(){var u="https://track.mearie.org/";_paq.push(['trackPageView'],['enableLinkTracking'],['setTrackerUrl',u+'matomo.php'],['setSiteId','4']);var d=document,g=d.createElement('script'),s=d.getElementsByTagName('script')[0];g.type='text/javascript';g.async=true;g.src=u+'matomo.js';s.parentNode.insertBefore(g,s)})()</script><noscript><p><img src="https://track.mearie.org/matomo.php?idsite=4&rec=1" style=border:0 alt></p></noscript></body></html>